// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: util/common.proto

#ifndef PROTOBUF_util_2fcommon_2eproto__INCLUDED
#define PROTOBUF_util_2fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dsm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_util_2fcommon_2eproto();
void protobuf_AssignDesc_util_2fcommon_2eproto();
void protobuf_ShutdownFile_util_2fcommon_2eproto();

class EmptyMessage;
class Arg;
class Args;
class Record;
class Records;
class FileParams;
class ConfigData;
class TermcheckDelta;

enum MessageTypes {
  MTYPE_RUN_KERNEL = 1,
  MTYPE_KERNEL_DONE = 2,
  MTYPE_PUT_REQUEST = 4,
  MTYPE_GET = 5,
  MTYPE_WORKER_SHUTDOWN = 8,
  MTYPE_REGISTER_WORKER = 9,
  MTYPE_START_CHECKPOINT = 10,
  MTYPE_FINISH_CHECKPOINT = 11,
  MTYPE_CHECKPOINT_DONE = 12,
  MTYPE_RESTORE = 13,
  MTYPE_RESTORE_DONE = 14,
  MTYPE_WORKER_FLUSH = 15,
  MTYPE_WORKER_FLUSH_DONE = 16,
  MTYPE_SHARD_ASSIGNMENT = 17,
  MTYPE_SHARD_ASSIGNMENT_DONE = 18,
  MTYPE_ITERATOR = 20,
  MTYPE_TERMCHECK_DONE = 21,
  MTYPE_TERMINATION = 22,
  MTYPE_SYNC_REPLY = 31,
  MTYPE_WORKER_APPLY = 33,
  MTYPE_WORKER_APPLY_DONE = 34,
  MTYPE_SWAP_TABLE = 35,
  MTYPE_CLEAR_TABLE = 37,
  MTYPE_ENABLE_TRIGGER = 38
};
bool MessageTypes_IsValid(int value);
const MessageTypes MessageTypes_MIN = MTYPE_RUN_KERNEL;
const MessageTypes MessageTypes_MAX = MTYPE_ENABLE_TRIGGER;
const int MessageTypes_ARRAYSIZE = MessageTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageTypes_descriptor();
inline const ::std::string& MessageTypes_Name(MessageTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageTypes_descriptor(), value);
}
inline bool MessageTypes_Parse(
    const ::std::string& name, MessageTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageTypes>(
    MessageTypes_descriptor(), name, value);
}
enum CompressionFormat {
  NONE = 0,
  LZO = 1,
  ZLIB = 2
};
bool CompressionFormat_IsValid(int value);
const CompressionFormat CompressionFormat_MIN = NONE;
const CompressionFormat CompressionFormat_MAX = ZLIB;
const int CompressionFormat_ARRAYSIZE = CompressionFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompressionFormat_descriptor();
inline const ::std::string& CompressionFormat_Name(CompressionFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompressionFormat_descriptor(), value);
}
inline bool CompressionFormat_Parse(
    const ::std::string& name, CompressionFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompressionFormat>(
    CompressionFormat_descriptor(), name, value);
}
// ===================================================================

class EmptyMessage : public ::google::protobuf::Message {
 public:
  EmptyMessage();
  virtual ~EmptyMessage();

  EmptyMessage(const EmptyMessage& from);

  inline EmptyMessage& operator=(const EmptyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyMessage& default_instance();

  void Swap(EmptyMessage* other);

  // implements Message ----------------------------------------------

  EmptyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyMessage& from);
  void MergeFrom(const EmptyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dsm.EmptyMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static EmptyMessage* default_instance_;
};
// -------------------------------------------------------------------

class Arg : public ::google::protobuf::Message {
 public:
  Arg();
  virtual ~Arg();

  Arg(const Arg& from);

  inline Arg& operator=(const Arg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arg& default_instance();

  void Swap(Arg* other);

  // implements Message ----------------------------------------------

  Arg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arg& from);
  void MergeFrom(const Arg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:dsm.Arg)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static Arg* default_instance_;
};
// -------------------------------------------------------------------

class Args : public ::google::protobuf::Message {
 public:
  Args();
  virtual ~Args();

  Args(const Args& from);

  inline Args& operator=(const Args& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Args& default_instance();

  void Swap(Args* other);

  // implements Message ----------------------------------------------

  Args* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Args& from);
  void MergeFrom(const Args& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dsm.Arg param = 1;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::dsm::Arg& param(int index) const;
  inline ::dsm::Arg* mutable_param(int index);
  inline ::dsm::Arg* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::dsm::Arg >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::dsm::Arg >*
      mutable_param();

  // @@protoc_insertion_point(class_scope:dsm.Args)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::dsm::Arg > param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static Args* default_instance_;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  void Swap(Record* other);

  // implements Message ----------------------------------------------

  Record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes value1 = 2;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 2;
  inline const ::std::string& value1() const;
  inline void set_value1(const ::std::string& value);
  inline void set_value1(const char* value);
  inline void set_value1(const void* value, size_t size);
  inline ::std::string* mutable_value1();
  inline ::std::string* release_value1();
  inline void set_allocated_value1(::std::string* value1);

  // required bytes value2 = 3;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 3;
  inline const ::std::string& value2() const;
  inline void set_value2(const ::std::string& value);
  inline void set_value2(const char* value);
  inline void set_value2(const void* value, size_t size);
  inline ::std::string* mutable_value2();
  inline ::std::string* release_value2();
  inline void set_allocated_value2(::std::string* value2);

  // required bytes value3 = 4;
  inline bool has_value3() const;
  inline void clear_value3();
  static const int kValue3FieldNumber = 4;
  inline const ::std::string& value3() const;
  inline void set_value3(const ::std::string& value);
  inline void set_value3(const char* value);
  inline void set_value3(const void* value, size_t size);
  inline ::std::string* mutable_value3();
  inline ::std::string* release_value3();
  inline void set_allocated_value3(::std::string* value3);

  // @@protoc_insertion_point(class_scope:dsm.Record)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();
  inline void set_has_value3();
  inline void clear_has_value3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value1_;
  ::std::string* value2_;
  ::std::string* value3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static Record* default_instance_;
};
// -------------------------------------------------------------------

class Records : public ::google::protobuf::Message {
 public:
  Records();
  virtual ~Records();

  Records(const Records& from);

  inline Records& operator=(const Records& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Records& default_instance();

  void Swap(Records* other);

  // implements Message ----------------------------------------------

  Records* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Records& from);
  void MergeFrom(const Records& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dsm.Record param = 1;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::dsm::Record& param(int index) const;
  inline ::dsm::Record* mutable_param(int index);
  inline ::dsm::Record* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::dsm::Record >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::dsm::Record >*
      mutable_param();

  // @@protoc_insertion_point(class_scope:dsm.Records)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::dsm::Record > param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static Records* default_instance_;
};
// -------------------------------------------------------------------

class FileParams : public ::google::protobuf::Message {
 public:
  FileParams();
  virtual ~FileParams();

  FileParams(const FileParams& from);

  inline FileParams& operator=(const FileParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileParams& default_instance();

  void Swap(FileParams* other);

  // implements Message ----------------------------------------------

  FileParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileParams& from);
  void MergeFrom(const FileParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dsm.Arg attr = 1;
  inline int attr_size() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 1;
  inline const ::dsm::Arg& attr(int index) const;
  inline ::dsm::Arg* mutable_attr(int index);
  inline ::dsm::Arg* add_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::dsm::Arg >&
      attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::dsm::Arg >*
      mutable_attr();

  // optional int32 compression = 2 [default = 0];
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 2;
  inline ::google::protobuf::int32 compression() const;
  inline void set_compression(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dsm.FileParams)
 private:
  inline void set_has_compression();
  inline void clear_has_compression();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::dsm::Arg > attr_;
  ::google::protobuf::int32 compression_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static FileParams* default_instance_;
};
// -------------------------------------------------------------------

class ConfigData : public ::google::protobuf::Message {
 public:
  ConfigData();
  virtual ~ConfigData();

  ConfigData(const ConfigData& from);

  inline ConfigData& operator=(const ConfigData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigData& default_instance();

  void Swap(ConfigData* other);

  // implements Message ----------------------------------------------

  ConfigData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigData& from);
  void MergeFrom(const ConfigData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num_workers = 1;
  inline bool has_num_workers() const;
  inline void clear_num_workers();
  static const int kNumWorkersFieldNumber = 1;
  inline ::google::protobuf::int32 num_workers() const;
  inline void set_num_workers(::google::protobuf::int32 value);

  // required int32 worker_id = 2;
  inline bool has_worker_id() const;
  inline void clear_worker_id();
  static const int kWorkerIdFieldNumber = 2;
  inline ::google::protobuf::int32 worker_id() const;
  inline void set_worker_id(::google::protobuf::int32 value);

  // required int32 master_id = 3;
  inline bool has_master_id() const;
  inline void clear_master_id();
  static const int kMasterIdFieldNumber = 3;
  inline ::google::protobuf::int32 master_id() const;
  inline void set_master_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dsm.ConfigData)
 private:
  inline void set_has_num_workers();
  inline void clear_has_num_workers();
  inline void set_has_worker_id();
  inline void clear_has_worker_id();
  inline void set_has_master_id();
  inline void clear_has_master_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 num_workers_;
  ::google::protobuf::int32 worker_id_;
  ::google::protobuf::int32 master_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static ConfigData* default_instance_;
};
// -------------------------------------------------------------------

class TermcheckDelta : public ::google::protobuf::Message {
 public:
  TermcheckDelta();
  virtual ~TermcheckDelta();

  TermcheckDelta(const TermcheckDelta& from);

  inline TermcheckDelta& operator=(const TermcheckDelta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TermcheckDelta& default_instance();

  void Swap(TermcheckDelta* other);

  // implements Message ----------------------------------------------

  TermcheckDelta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TermcheckDelta& from);
  void MergeFrom(const TermcheckDelta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required double delta = 2;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 2;
  inline double delta() const;
  inline void set_delta(double value);

  // required int64 updates = 3;
  inline bool has_updates() const;
  inline void clear_updates();
  static const int kUpdatesFieldNumber = 3;
  inline ::google::protobuf::int64 updates() const;
  inline void set_updates(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:dsm.TermcheckDelta)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_delta();
  inline void clear_has_delta();
  inline void set_has_updates();
  inline void clear_has_updates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double delta_;
  ::google::protobuf::int64 updates_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_util_2fcommon_2eproto();
  friend void protobuf_AssignDesc_util_2fcommon_2eproto();
  friend void protobuf_ShutdownFile_util_2fcommon_2eproto();

  void InitAsDefaultInstance();
  static TermcheckDelta* default_instance_;
};
// ===================================================================


// ===================================================================

// EmptyMessage

// -------------------------------------------------------------------

// Arg

// required bytes key = 1;
inline bool Arg::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arg::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arg::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arg::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Arg::key() const {
  return *key_;
}
inline void Arg::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Arg::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Arg::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arg::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Arg::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Arg::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes value = 2;
inline bool Arg::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arg::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arg::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arg::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Arg::value() const {
  return *value_;
}
inline void Arg::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Arg::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Arg::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Arg::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Arg::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Arg::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Args

// repeated .dsm.Arg param = 1;
inline int Args::param_size() const {
  return param_.size();
}
inline void Args::clear_param() {
  param_.Clear();
}
inline const ::dsm::Arg& Args::param(int index) const {
  return param_.Get(index);
}
inline ::dsm::Arg* Args::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::dsm::Arg* Args::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dsm::Arg >&
Args::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::dsm::Arg >*
Args::mutable_param() {
  return &param_;
}

// -------------------------------------------------------------------

// Record

// required bytes key = 1;
inline bool Record::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Record::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Record::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Record::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Record::key() const {
  return *key_;
}
inline void Record::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Record::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Record::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Record::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes value1 = 2;
inline bool Record::has_value1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Record::set_has_value1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Record::clear_has_value1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Record::clear_value1() {
  if (value1_ != &::google::protobuf::internal::kEmptyString) {
    value1_->clear();
  }
  clear_has_value1();
}
inline const ::std::string& Record::value1() const {
  return *value1_;
}
inline void Record::set_value1(const ::std::string& value) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(value);
}
inline void Record::set_value1(const char* value) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(value);
}
inline void Record::set_value1(const void* value, size_t size) {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  value1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record::mutable_value1() {
  set_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    value1_ = new ::std::string;
  }
  return value1_;
}
inline ::std::string* Record::release_value1() {
  clear_has_value1();
  if (value1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value1_;
    value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record::set_allocated_value1(::std::string* value1) {
  if (value1_ != &::google::protobuf::internal::kEmptyString) {
    delete value1_;
  }
  if (value1) {
    set_has_value1();
    value1_ = value1;
  } else {
    clear_has_value1();
    value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes value2 = 3;
inline bool Record::has_value2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Record::set_has_value2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Record::clear_has_value2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Record::clear_value2() {
  if (value2_ != &::google::protobuf::internal::kEmptyString) {
    value2_->clear();
  }
  clear_has_value2();
}
inline const ::std::string& Record::value2() const {
  return *value2_;
}
inline void Record::set_value2(const ::std::string& value) {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  value2_->assign(value);
}
inline void Record::set_value2(const char* value) {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  value2_->assign(value);
}
inline void Record::set_value2(const void* value, size_t size) {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  value2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record::mutable_value2() {
  set_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    value2_ = new ::std::string;
  }
  return value2_;
}
inline ::std::string* Record::release_value2() {
  clear_has_value2();
  if (value2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value2_;
    value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record::set_allocated_value2(::std::string* value2) {
  if (value2_ != &::google::protobuf::internal::kEmptyString) {
    delete value2_;
  }
  if (value2) {
    set_has_value2();
    value2_ = value2;
  } else {
    clear_has_value2();
    value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes value3 = 4;
inline bool Record::has_value3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Record::set_has_value3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Record::clear_has_value3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Record::clear_value3() {
  if (value3_ != &::google::protobuf::internal::kEmptyString) {
    value3_->clear();
  }
  clear_has_value3();
}
inline const ::std::string& Record::value3() const {
  return *value3_;
}
inline void Record::set_value3(const ::std::string& value) {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  value3_->assign(value);
}
inline void Record::set_value3(const char* value) {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  value3_->assign(value);
}
inline void Record::set_value3(const void* value, size_t size) {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  value3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Record::mutable_value3() {
  set_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    value3_ = new ::std::string;
  }
  return value3_;
}
inline ::std::string* Record::release_value3() {
  clear_has_value3();
  if (value3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value3_;
    value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Record::set_allocated_value3(::std::string* value3) {
  if (value3_ != &::google::protobuf::internal::kEmptyString) {
    delete value3_;
  }
  if (value3) {
    set_has_value3();
    value3_ = value3;
  } else {
    clear_has_value3();
    value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Records

// repeated .dsm.Record param = 1;
inline int Records::param_size() const {
  return param_.size();
}
inline void Records::clear_param() {
  param_.Clear();
}
inline const ::dsm::Record& Records::param(int index) const {
  return param_.Get(index);
}
inline ::dsm::Record* Records::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::dsm::Record* Records::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dsm::Record >&
Records::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::dsm::Record >*
Records::mutable_param() {
  return &param_;
}

// -------------------------------------------------------------------

// FileParams

// repeated .dsm.Arg attr = 1;
inline int FileParams::attr_size() const {
  return attr_.size();
}
inline void FileParams::clear_attr() {
  attr_.Clear();
}
inline const ::dsm::Arg& FileParams::attr(int index) const {
  return attr_.Get(index);
}
inline ::dsm::Arg* FileParams::mutable_attr(int index) {
  return attr_.Mutable(index);
}
inline ::dsm::Arg* FileParams::add_attr() {
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::dsm::Arg >&
FileParams::attr() const {
  return attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::dsm::Arg >*
FileParams::mutable_attr() {
  return &attr_;
}

// optional int32 compression = 2 [default = 0];
inline bool FileParams::has_compression() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileParams::set_has_compression() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileParams::clear_has_compression() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileParams::clear_compression() {
  compression_ = 0;
  clear_has_compression();
}
inline ::google::protobuf::int32 FileParams::compression() const {
  return compression_;
}
inline void FileParams::set_compression(::google::protobuf::int32 value) {
  set_has_compression();
  compression_ = value;
}

// -------------------------------------------------------------------

// ConfigData

// required int32 num_workers = 1;
inline bool ConfigData::has_num_workers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigData::set_has_num_workers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigData::clear_has_num_workers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigData::clear_num_workers() {
  num_workers_ = 0;
  clear_has_num_workers();
}
inline ::google::protobuf::int32 ConfigData::num_workers() const {
  return num_workers_;
}
inline void ConfigData::set_num_workers(::google::protobuf::int32 value) {
  set_has_num_workers();
  num_workers_ = value;
}

// required int32 worker_id = 2;
inline bool ConfigData::has_worker_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigData::set_has_worker_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigData::clear_has_worker_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigData::clear_worker_id() {
  worker_id_ = 0;
  clear_has_worker_id();
}
inline ::google::protobuf::int32 ConfigData::worker_id() const {
  return worker_id_;
}
inline void ConfigData::set_worker_id(::google::protobuf::int32 value) {
  set_has_worker_id();
  worker_id_ = value;
}

// required int32 master_id = 3;
inline bool ConfigData::has_master_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigData::set_has_master_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigData::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigData::clear_master_id() {
  master_id_ = 0;
  clear_has_master_id();
}
inline ::google::protobuf::int32 ConfigData::master_id() const {
  return master_id_;
}
inline void ConfigData::set_master_id(::google::protobuf::int32 value) {
  set_has_master_id();
  master_id_ = value;
}

// -------------------------------------------------------------------

// TermcheckDelta

// required int32 index = 1;
inline bool TermcheckDelta::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TermcheckDelta::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TermcheckDelta::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TermcheckDelta::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 TermcheckDelta::index() const {
  return index_;
}
inline void TermcheckDelta::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required double delta = 2;
inline bool TermcheckDelta::has_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TermcheckDelta::set_has_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TermcheckDelta::clear_has_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TermcheckDelta::clear_delta() {
  delta_ = 0;
  clear_has_delta();
}
inline double TermcheckDelta::delta() const {
  return delta_;
}
inline void TermcheckDelta::set_delta(double value) {
  set_has_delta();
  delta_ = value;
}

// required int64 updates = 3;
inline bool TermcheckDelta::has_updates() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TermcheckDelta::set_has_updates() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TermcheckDelta::clear_has_updates() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TermcheckDelta::clear_updates() {
  updates_ = GOOGLE_LONGLONG(0);
  clear_has_updates();
}
inline ::google::protobuf::int64 TermcheckDelta::updates() const {
  return updates_;
}
inline void TermcheckDelta::set_updates(::google::protobuf::int64 value) {
  set_has_updates();
  updates_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dsm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dsm::MessageTypes>() {
  return ::dsm::MessageTypes_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dsm::CompressionFormat>() {
  return ::dsm::CompressionFormat_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_util_2fcommon_2eproto__INCLUDED
